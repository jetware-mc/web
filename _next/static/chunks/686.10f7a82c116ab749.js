"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[686],{6686:function(e,n,t){t.r(n),t.d(n,{default:function(){return P}});var r=t(5893),i=t(7294),c=t(4184),o=t.n(c),a=t(2212),g=t(3460),l=t(9342),f=t(8416),u=function(e,n){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=!(arguments.length>3)||void 0===arguments[3]||arguments[3],[c,o]=(0,i.useState)(!1),[a,g]=(0,i.useState)(!1);return(0,i.useEffect)(()=>{if(!(null==e?void 0:e.current))return;let i=new IntersectionObserver(e=>{let[t]=e,{isIntersecting:r,target:c}=t;o(r),r&&n&&(i.unobserve(c),g(!0))},t);return!a&&r&&i.observe(e.current),()=>i.disconnect()},[e,n,t,a,r]),c},s=function(){let e=void 0!==window.navigator?navigator.userAgent.match(/iphone|ipod|ipad/i):void 0,n=(0,i.useRef)(()=>({w:0,h:0})),t=(0,i.useRef)(()=>Math.abs(window.orientation)),r=(0,i.useCallback)(()=>{let e=document.createElement("div");e.style.position="fixed",e.style.height="100vh",e.style.width=0,e.style.top=0,document.documentElement.appendChild(e),t.current.w=90===n.current?e.offsetHeight:window.innerWidth,t.current.h=90===n.current?window.innerWidth:e.offsetHeight,document.documentElement.removeChild(e),e=null},[]),c=(0,i.useCallback)(()=>e?(r(),90!==Math.abs(window.orientation))?t.current.h:t.current.w:window.innerHeight,[r,!0,e]),o=(0,i.useCallback)(()=>({width:window.innerWidth,height:c()}),[c,!0]),[a,g]=(0,i.useState)(()=>o());return(0,i.useEffect)(()=>{let e=()=>{g(o())};return window.addEventListener("resize",e),()=>{window.removeEventListener("resize",e)}},[o,!0]),a};let v=e=>e&&e.offsetHeight,d={desktop:2080,laptop:1680,tablet:1024,mobile:696,mobileS:400},m=e=>e.split(" ").map(e=>Number(e)/255),p=e=>{e.traverse(e=>{if(e.isMesh){if(e.geometry.dispose(),e.material.isMaterial)x(e.material);else for(let n of e.material)x(n)}})},x=e=>{for(let n of(e.dispose(),Object.keys(e))){let t=e[n];t&&"object"==typeof t&&"minFilter"in t&&t.dispose()}},y=e=>{e.dispose(),e.forceContextLoss(),e=null},z=e=>{for(let n of e)n.parent.remove(n)},_=e=>{let{rgbBackground:n,themeId:t,colorWhite:c}=e.theme,x=(0,i.useRef)(Date.now()),_=(0,i.useRef)(),P=(0,i.useRef)(),w=(0,i.useRef)(),h=(0,i.useRef)(),b=(0,i.useRef)(),E=(0,i.useRef)(),S=(0,i.useRef)(),R=(0,i.useRef)(),L=(0,i.useRef)(),C=(0,i.useRef)(),k=(0,i.useRef)(),M=(0,i.useRef)(),F=(0,f.Z)(),I=u(_),A=s();return(0,i.useEffect)(()=>{let{innerWidth:e,innerHeight:n}=window;return P.current=new a.FM8(.8,.5),w.current=new a.CP7({canvas:_.current,antialias:!1,powerPreference:"high-performance"}),w.current.setSize(e,n),w.current.setPixelRatio(1),w.current.outputEncoding=h.current=new a.cPb(54,e/n,.1,100),h.current.position.z=52,b.current=new a.xsS,R.current=new a.xoR,R.current.onBeforeCompile=e=>{S.current=a.rDY.merge([a.rBU.ambient,a.rBU.lights,e.uniforms,{time:{type:"f",value:0}}]),e.uniforms=S.current,e.vertexShader="\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\nfloat turbulence(vec3 p) {\n  float w = 100.0;\n  float t = -.5;\n  for (float f = 1.0 ; f <= 10.0 ; f++) {\n    float power = pow(2.0, f);\n    t += abs(pnoise(vec3(power * p), vec3(10.0, 10.0, 10.0)) / power);\n  }\n  return t;\n}\n// START\nuniform float time;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying float noise;\nvarying vec3 vViewPosition;\nvoid main() {\n  #include <beginnormal_vertex>\n  #include <defaultnormal_vertex>\n  #include <begin_vertex>\n  #include <project_vertex>\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize(transformedNormal);\n  #endif\n  vViewPosition = - mvPosition.xyz;\n  vUv = uv;\n  noise = turbulence(0.01 * position + normal + time * 0.8);\n  vec3 displacement = vec3((position.x) * noise, position.y * noise, position.z * noise);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4((position + normal) + displacement, 1.0);\n}\n",e.fragmentShader="\n#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform float time;\nvarying vec2 vUv;\nvarying vec3 newPosition;\nvarying float noise;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <envmap_physical_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n  #include <clipping_planes_fragment>\n  vec3 color = vec3(vUv * (0.2 - 2.0 * noise), 1.0);\n  vec3 finalColors = vec3(color.r * 1.3, color.b * 1.2, color.b * 0.95);\n  vec4 diffuseColor = vec4(cos(finalColors * noise * 3.0), 1.0);\n  ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n  vec3 totalEmissiveRadiance = emissive;\n  #include <logdepthbuf_fragment>\n  #include <map_fragment>\n  #include <color_fragment>\n  #include <alphamap_fragment>\n  #include <alphatest_fragment>\n  #include <specularmap_fragment>\n  #include <normal_fragment_begin>\n  #include <normal_fragment_maps>\n  #include <emissivemap_fragment>\n  #include <lights_phong_fragment>\n  #include <lights_fragment_begin>\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n  #include <aomap_fragment>\n  vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  #include <envmap_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n}\n"},L.current=new a.Aip(32,128,128),C.current=new a.Kj0(L.current,R.current),C.current.position.z=0,C.current.modifier=Math.random(),b.current.add(C.current),()=>{p(b.current),y(w.current)}},[]),(0,i.useEffect)(()=>{let e=new a.Ox3(c,.6),r=new a.Mig(c,"light"===t?.8:.1);return e.position.z=200,e.position.x=100,e.position.y=100,E.current=[e,r],b.current.background=new a.Ilk(...m(n)),E.current.forEach(e=>b.current.add(e)),()=>{z(E.current)}},[n,c,t]),(0,i.useEffect)(()=>{let{width:e,height:n}=A,t=n+.3*n;w.current.setSize(e,t),h.current.aspect=e/t,h.current.updateProjectionMatrix(),F&&w.current.render(b.current,h.current),e<=d.mobile?(C.current.position.x=14,C.current.position.y=10):e<=d.tablet?(C.current.position.x=18,C.current.position.y=14):(C.current.position.x=22,C.current.position.y=16)},[F,A]),(0,i.useEffect)(()=>{let e=e=>{let{rotation:n}=C.current,t={x:e.clientX/window.innerWidth,y:e.clientY/window.innerHeight};M.current||(M.current=(0,g.S3)(n.toArray(),e=>n.set(e[0],e[1],C.current.rotation.z))),k.current=(0,g.ST)({from:M.current.get(),to:[t.y/2,t.x/2],stiffness:30,damping:20,velocity:M.current.getVelocity(),mass:2,restSpeed:1e-4}).start(M.current)};return!F&&I&&window.addEventListener("mousemove",e),()=>{var n;window.removeEventListener("mousemove",e),null===(n=k.current)||void 0===n||n.stop()}},[I,F]),(0,i.useEffect)(()=>{let e;let n=()=>{e=requestAnimationFrame(n),void 0!==S.current&&(S.current.time.value=5e-5*(Date.now()-x.current)),C.current.rotation.z+=.001,w.current.render(b.current,h.current)};return!F&&I?n():w.current.render(b.current,h.current),()=>{cancelAnimationFrame(e)}},[I,F]),(0,r.jsx)(l.ZP,{appear:!0,in:!0,onEnter:v,timeout:3e3,children:n=>(0,r.jsx)("canvas",{"aria-hidden":!0,className:o()("displacement-sphere","displacement-sphere--".concat(n)),ref:_,...e})})};var P=_},8416:function(e,n,t){var r=t(7294);n.Z=function(){let[e,n]=(0,r.useState)(()=>{var e;return null===(e=window.matchMedia)||void 0===e?void 0:e.call(window,"(prefers-reduced-motion: reduce)").matches});return(0,r.useEffect)(()=>{var e;let t=null===(e=window.matchMedia)||void 0===e?void 0:e.call(window,"(prefers-reduced-motion: reduce)"),r=()=>{n(null==t?void 0:t.matches)};try{return null==t||t.addEventListener("change",e=>r()),()=>{null==t||t.removeEventListener("change",e=>r())}}catch(i){return null==t||t.addListener(e=>r()),()=>{null==t||t.removeListener(e=>r())}}},[]),e}}}]);